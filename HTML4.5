<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EEG4.5</title>
  <style>
    html,body{height:100%;margin:0;background:#000;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto;overflow:hidden}
    #overlay{position:fixed;left:12px;top:12px;z-index:10;max-width:360px}
    .panel{background:rgba(0,0,0,0.45);padding:12px;border-radius:8px;backdrop-filter:blur(4px)}
    #result{display:none;padding:18px;margin-top:12px;border-radius:8px;font-weight:700}
    #result.win{background:linear-gradient(90deg,#0f0,#005500);color:#001}
    #result.lose{background:linear-gradient(90deg,#f00,#550000);color:#fff}
    #canvas-container{width:100%;height:100vh;display:block}
    button,input{margin-top:8px}
    input[type=range]{width:100%}
    button{padding:8px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.02);color:inherit}
    label{font-size:13px;display:block;margin-top:10px}
    #stats{margin-top:8px;font-size:14px}
    #crosshair{position:fixed;left:50%;top:50%;width:20px;height:20px;margin-left:-10px;margin-top:-10px;z-index:5;pointer-events:none}
    #crosshair:before,#crosshair:after{content:"";position:absolute;background:#fff}
    #crosshair:before{left:9px;top:0;width:2px;height:20px}
    #crosshair:after{left:0;top:9px;width:20px;height:2px}
  </style>
</head>
<body>
  <div id="overlay">
    <div class="panel">
      <div><strong>EEG4.5</strong></div>
      <div><strong>rule number 1: everything is possible</strong></div>
      <ul style="margin:8px 0 0 18px;font-size:13px">
        <li>shoot the ball to win</li>
        <li>arrowkeys to move</li>
        <li>space shoot bullet</li>
        <li>ball health: red: 100~70%, purple: 70~30%, blue: 30~0%, green 0%</li>
        <li>If you want to(find the ultimate bug) and make hits needed -30</li>
      </ul>
      <label for="sensitivity">Rotation sensitivity</label>
      <input id="sensitivity" type="range" min="0.003" max="0.007" step="0.0001" value="0.015">
      <div id="stats">
        Hits needed: <span id="hits">10</span><br>
        Time left: <span id="timer">30</span>s
      </div>
      <button id="resetBtn">Reset</button>
      <div id="result"></div>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="canvas-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(0,0,0);

    // Stars background
    function createStars(){
      const starCount = 5000;
      const geom = new THREE.BufferGeometry();
      const positions = [];
      for(let i=0;i<starCount;i++){
        positions.push((Math.random()-0.5)*4000);
        positions.push((Math.random()-0.5)*4000);
        positions.push((Math.random()-0.5)*4000);
      }
      geom.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
      const mat = new THREE.PointsMaterial({color:0xffffff,size:2.0,sizeAttenuation:true});
      return new THREE.Points(geom,mat);
    }
    scene.add(createStars());

    // Ball
    const ballRadius = 15;
    const ballGeom = new THREE.SphereGeometry(ballRadius, 32, 32);
    const ballMat = new THREE.MeshStandardMaterial({color:0xff0000, emissive:0x220000});
    const ball = new THREE.Mesh(ballGeom, ballMat);
    scene.add(ball);

    const light = new THREE.PointLight(0xffffff,1.2,0);
    light.position.set(200,200,200);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff,0.3));

    function randomUnit(){
      const v = new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
      return v.normalize();
    }
    const sphereRadius = 900;
    let ballPos = randomUnit().multiplyScalar(sphereRadius*0.4);
    let speed = 1.5;
    let ballVel = randomUnit().multiplyScalar(speed);
    ball.position.copy(ballPos);

    // Controls
    let accel = 0.015;
    const decay = 0.9;
    let rotVel = new THREE.Vector3();
    const keys = {ArrowLeft:false,ArrowRight:false,ArrowUp:false,ArrowDown:false,KeyA:false,KeyD:false};
    window.addEventListener('keydown',(e)=>{if(e.code in keys) keys[e.code]=true; if(e.key==='r'||e.key==='R') reset(); if(e.code==='Space') shoot();});
    window.addEventListener('keyup',(e)=>{if(e.code in keys) keys[e.code]=false;});

    function updateCamera(dt){
      if(keys.ArrowUp) rotVel.x += accel;   // pitch up
      if(keys.ArrowDown) rotVel.x -= accel; // pitch down
      if(keys.ArrowLeft) rotVel.y += accel; // yaw left
      if(keys.ArrowRight) rotVel.y -= accel;// yaw right
      if(keys.KeyA) rotVel.z += accel;      // roll left
      if(keys.KeyD) rotVel.z -= accel;      // roll right

      // Apply local axis rotations
      const q = new THREE.Quaternion();
      q.setFromAxisAngle(new THREE.Vector3(1,0,0), rotVel.x);
      camera.quaternion.multiply(q);
      q.setFromAxisAngle(new THREE.Vector3(0,1,0), rotVel.y);
      camera.quaternion.multiply(q);
      q.setFromAxisAngle(new THREE.Vector3(0,0,1), rotVel.z);
      camera.quaternion.multiply(q);

      rotVel.multiplyScalar(decay);
    }

    // Bullets
    const bullets = [];
    const bulletSpeed = 20;

    function shoot(){
      const bulletGeom = new THREE.SphereGeometry(2,8,8);
      const bulletMat = new THREE.MeshBasicMaterial({color:0xffff00});
      const bullet = new THREE.Mesh(bulletGeom, bulletMat);
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
      bullet.position.copy(camera.position);
      bullets.push({mesh:bullet,vel:dir.multiplyScalar(bulletSpeed)});
      scene.add(bullet);
    }

    // Game state
    let hitsLeft = 10;
    const hitsEl = document.getElementById('hits');
    const timerEl = document.getElementById('timer');
    const resultDiv = document.getElementById('result');

    let timeLeft = 30;
    let timerActive = true;
    setInterval(()=>{
      if(timerActive){
        timeLeft--;
        timerEl.textContent = timeLeft;
        if(timeLeft<=0){
          timerActive = false;
          endGame(false);
        }
      }
    },1000);

    function stepBall(){
      ballPos.add(ballVel.clone());
      const dist = ballPos.length();
      if(dist + ballRadius >= sphereRadius){
        const normal = ballPos.clone().normalize();
        ballPos = normal.clone().multiplyScalar(sphereRadius - ballRadius - 0.1);
        const v = ballVel.clone();
        const dot = v.dot(normal);
        const reflected = v.clone().sub(normal.clone().multiplyScalar(2*dot));
        ballVel = reflected;
      }
      ball.position.copy(ballPos);
    }

    function animate(t){
      requestAnimationFrame(animate);
      const dt = 0.016;

      stepBall();

      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.mesh.position.add(b.vel.clone().multiplyScalar(dt*60));
        if(b.mesh.position.length()>sphereRadius*2){
          scene.remove(b.mesh);
          bullets.splice(i,1);
          continue;
        }
        if(b.mesh.position.distanceTo(ball.position) < ballRadius){
          scene.remove(b.mesh);
          bullets.splice(i,1);
          hitsLeft--;
          if(hitsLeft===7){ball.material.color.set(0x800080);} // purple
          if(hitsLeft===4){ball.material.color.set(0x0000ff);} // blue
          hitsEl.textContent = hitsLeft;
          if(hitsLeft<=0){
            timerActive = false;
            endGame(true);
          }
        }
      }

      updateCamera(dt);
      renderer.render(scene,camera);
    }
    requestAnimationFrame(animate);

    function endGame(win){
      resultDiv.style.display = 'block';
      if(win){
        resultDiv.className = 'win';
        resultDiv.textContent = 'You win! And you get the';
        ball.material.color.set(0x00ff00);
      } else {
        resultDiv.className = 'lose';
        resultDiv.textContent = 'Time up! Failure!';
      }
    }

    function reset(){
      hitsLeft = 10;
      hitsEl.textContent = hitsLeft;
      timeLeft = 30;
      timerEl.textContent = timeLeft;
      timerActive = true;
      resultDiv.style.display = 'none';
      resultDiv.className = '';
      ball.material.color.set(0xff0000);
      ballPos = randomUnit().multiplyScalar(sphereRadius*0.4);
      ballVel = randomUnit().multiplyScalar(speed);
      ball.position.copy(ballPos);
    }

    document.getElementById('resetBtn').addEventListener('click', reset);

    document.getElementById('sensitivity').addEventListener('input',(e)=>{
      accel = parseFloat(e.target.value);
    });

    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
